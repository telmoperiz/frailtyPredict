#' Predict risk of terminal event
#'
#' This method predicts the risk of terminal event in the interval \eqn{(t, t+w)}
#' given covariates and recurrent event history.
#'
#' @details
#' If `CI='MC'`, the Confidence Interval is computed my Monte Carlo. The steps
#' are: (i) draw a sample from the asymptoticdistribution of the parameter,
#' (ii) compute the risk of the ternimal event with each drawn parameter, and
#' (iii) take the `sig/2` and `1-sig/2` percentiles of those values.
#'
#' If `CI='DM'`, the Confidence Interval is computed my the Delta-method. That is,
#' the derivative of the expression for the predicted risk (numerically
#' approximating the integrals) is computed. Then, the variance of the prediction
#' is estimated multiplying the derivative to the asymptotic variance.
#'
#' The default number of numerical integration nodes (the same as for estimation
#' of the model) may be to large if `CI='MC'` or if the function must be applied
#' to a large number of times `t` or horizons `w`. The user may alter this by
#' setting `numint_nodes`.
#'
#' If the function is called for several times `t` or horizons `w`, the user can
#' provide a sample `par_sample` from the asymptotic distribution of the
#' parameters. This allows fixing the sample acroos all calls. The sample may be
#' constructed by bootstrapping or by a normal approximation, using
#' [asympt_draw.SharedModel()].
#'
#'
#' @param obj [SharedModel()] object with fit results.
#' @param t non-negative numeric Prediction point (start of predition interval).
#' @param w positive numeric Prediction horizon (marks the end of prediction
#' interval).
#' @param covs list with covariate values:
#' * `$terminal` = numeric vector Covariates for terminal event model.
#' * `$recurrent` = numeric vector Covariates for recurrent events model.
#' @param hist numeric vector with recurrent event history. Default is `c()`
#' (i.e., `NULL`), which corresponds to zero events before `t`.
#' @param type Whether to predict given recurrent event history or not. Values:
#' `"unconditional"` (default), to predict just conditioning on covariates, or
#' `"conditional"` to predict given recurrent event history and covariates.
#' @param CI Compute Confidence Interval? `MC` (Default: Monte Carlo) or `DM`
#' (Delta-method). Any other value does not compute the Confidence Interval.
#' @param sig Significance of the confidence interval: An interval of `1 - sig`
#' confidence is computed. Default: `0.05`.
#' @param MC_B Number of Monte Carlo draws. Default is `100`.
#' @param numint_nodes Number of numerical integration nodes. Default is the
#' same as for estimation.
#' @param par_sample A matrix with a draw from the asymptotic distribution of
#' parameters (for Monte Carlo Confidence Intervals). Can be generated by
#' [asympt_draw.SharedModel()].
#'
#' @return numeric Predicted risk of terminal event. If `CI = TRUE`, the
#' returned values has attributes `"CI_lower"` and `"CI_upper"`.
#'
#' @examples
#'
#' @export
predict.SharedModel <- function(obj, t, w, covs, hist=NULL,
                                type='unconditional', CI = 'MC',
                                sig = 0.05, MC_B=100,
                                numint_nodes=NULL,
                                par_sample=NULL){

  ##### Checking correct inputs #####

  # Prediction point
  if (length(t)>1){
    stop('Invalid length for t. This function is not vectorized, use apply()')
  }

  if (t<0){
    stop('t must be non-negative')
  }

  # Prediction horizon
  if (length(w)>1){
    stop('Invalid length for w. This function is not vectorized, use apply()')
  }

  if (w<=0){
    stop('w must be positive')
  }

  # Covariates
  if ( length(covs$terminal) != length(param_coef(obj)$terminal) |
       length(covs$recurrent) != length(param_coef(obj)$recurrent)) {
    stop('Invalid lenght of covariates')
  }

  # Event history
  if(length(hist) > 0){

    if(any(diff(hist) <= 0)){
      stop('Recurrent event times must be in increasing order')
    }

    if(max(hist)>t){
      stop('Recurrent event times must be smaller than t')
    }
  }

  # Type
  type_supp <- c('unconditional', 'conditional')
  if (!(type %in% type_supp) ){
    stop(paste('Invalid value for type. Supported:',
         paste(type_supp, collapse = ', ')))
  }

  # Valid parameter sample
  if (!is.null(par_sample)){

    if (ncol(par_sample) != length(obj$par)){
      stop('Invalid sample: incorrect number of parameters.')
    }

    if (any(par_sample[,obj$optim_control$posit_cons] <= 0)){
      stop('Invalid sample: positivity constraint is not satisfied.')
    }
  }

  ##### Collect information #####

  # Type of confidence interval
  if (is.null(CI) | is.na(CI) | length(CI) > 1){
    CI_MC <- FALSE
    CI_DM <- FALSE
  } else {
    CI_MC <- CI == 'MC'
    CI_DM <- CI == 'DM'
  }

  #Parameters of the model (coefficients and frailty parameters)
  parbeta<-param_coef(obj)
  parfrail<-param_frailty(obj)

  #Get baseline survival functions at t and t+w
  St_d<-base_survival(obj, t=t, process = 'terminal', gradient = CI_DM)
  Sw_d<-base_survival(obj, t=t+w, process = 'terminal', gradient = CI_DM)

  #Define the information regarding frailty pdf (shape and param)
  pdfinfo<-list(func=obj$funtion_shapes$pdf,
                param=parfrail[grepl('shape', names(parfrail))])

  # Only needed for conditional probability
  if (type == 'conditional'){

    #If hist is a Surv object (i.e., as in the data), get the recurrent times
    if (class(hist)=='Surv'){
      Tjs<-get_rec_times(hist)

      #If not, we just received the raw Tjs
    } else {
      Tjs<-hist
    }

    #Number of recurrent events prior to t
    J<-length(Tjs[Tjs<=t])

    #Survival function given history
    S_r<-surv_given_history(obj, t=t, Tjs=Tjs, gradient = CI_DM)

  } else {
    J <- NULL
    S_r <- NULL
  }

  ##### Find prediction #####

  # Check whether there is sample for MC integration (if it is needed)
  # Change numerical integration nodes
  if (!is.null(numint_nodes)){
    obj$optim_control$MC_N <- numint_nodes
  }
  obj <- check_intsample(obj)

  NUM <- pred_num(St_d, Sw_d, S_r, J, alpha=parfrail['alpha'], parbeta=parbeta,
                  covs=covs, pdfinfo=pdfinfo, intcontrol = obj$optim_control,
                  par_pos = obj$par_pos, type = type, gradient = CI_DM)

  DEN <- pred_den(St_d, S_r, J, alpha=parfrail['alpha'], parbeta=parbeta,
                  covs=covs, pdfinfo=pdfinfo, intcontrol = obj$optim_control,
                  par_pos = obj$par_pos, type = type, gradient = CI_DM)

  # Predicted risk of terminal
  pred <- NUM/DEN
  attr(pred, 'gradient') <- NULL # Remove attribute

  ##### Find Confidence Interval #####

  if (CI_MC) {

    # Draw from asymptotic distribution
    if (is.null(par_sample)){
      thetas <- asympt_draw(obj, n = MC_B)
    } else {
      thetas <- par_sample
    }

    # Compute the predictions for each simulated theta
    sim_probs <- vector(mode = 'double', length = MC_B)
    for (b in seq_along(sim_probs)){

      # Copy the model and chage the estimated parameter
      theta_model <- obj
      theta_model$par <- thetas[b,]

      # Predict
      sim_probs[b] <- predict(theta_model, t = t, w = w, covs = covs,
                              hist = hist, type = type, CI = 'No')
    }

    # Percentiles
    CI_lower <- unname(quantile(sim_probs, probs = sig/2, na.rm = TRUE))
    CI_upper <- unname(quantile(sim_probs, probs = 1-sig/2, na.rm = TRUE))

    # Add attributes
    attr(pred, "CI_lower") <- CI_lower
    attr(pred, "CI_upper") <- CI_upper

  } else if (CI_DM) {

    # Get pred_grad in terms of numerator and denominator gradients
    dNUM <- attr(NUM, 'gradient')
    dDEN <- attr(DEN, 'gradient')

    pred_grad <- ( dNUM * DEN - NUM * dDEN)  / DEN^2

    # Parameter variance
    VAR <- obj$varmat

    # Delta method
    pred_var <- t(pred_grad) %*% VAR %*% pred_grad

    # Confidence intervals
    z <-stats::qnorm(1 - sig/2)
    CI_lower <- pred - z * sqrt(pred_var)
    CI_upper <- pred + z * sqrt(pred_var)

    # Add attributes
    attr(pred, "CI_lower") <- CI_lower
    attr(pred, "CI_upper") <- CI_upper
  }

  return(pred)
}


#' Plot with terminal event risk predictions
#'
#' Creates a plot terminal event risk predictions for a list of individuals.
#' The ploting engine is python's matplotlib library.
#'
#' @details
#' Using this functionality requires installing additional R packages: [jsonlite],
#' [reticulate], and [rlist].
#'
#' Before running the function, the user must define a path for a python environment
#' (which must have matplotlib installed). To do so, see [reticulate::use_python()],
#' [reticulate::use_virtualenv()], and [reticulate::py_install()].
#'
#' A temporary JSON file is created in the directory specified by `filename`.
#' This file contains plot information and is read by the python script. Set
#' `del_temp=TRUE` to delete the file. Set `check_temp=TRUE` to search for a
#' preexisting JSON file with path
#' `<directory in filename>/temp_<name in filename>.json`.
#'
#' @param obj [SharedModel()] object with fit results.
#' @param filename Name or path where the plot is saved (e.g., `"plot.png"`).
#' @param t non-negative numeric Prediction point (start of predition interval).
#' @param ws vector of positive numeric prediction horizons (the risk of terminal
#' between `t` and `t+w` for every element `w` in `ws` is plotted).
#' @param individuals A list of individual information. Each element of the list
#' must be a named list with the following information:
#' * `$covs` = list with covariate values, see [predict.SharedModel()].
#' * `$hist` = numeric vector with recurrent event history,
#' see [predict.SharedModel()]. Default is `NULL` (no events).
#' * `$type` = Whether to predict given recurrent event history or not. Either
#' `"unconditional"` (no, default) or `"conditional"` (yes).
#' * `$ci` = `TRUE` to plot confidence interval for the individual.
#' Default is `FALSE`.
#' * `$name` = Label of the individual (to display in the legend). Default is
#' `NA` (automatic naming).
#' @param CI_method Set to `"MC"` for Monte Carlo method (default) or `"DM"` for
#' Delta-method. See [predict.SharedModel()].
#' @param sig Significance of the confidence interval. Default is `0.05`.
#' See [predict.SharedModel()].
#' @param MC_B Number of Monte Carlo draws. Default is `100`.
#' See [predict.SharedModel()].
#' @param numint_nodes Number of numerical integration nodes.
#' See [predict.SharedModel()].
#' @param check_temp `TRUE` to check for the existence of the temporary JSON
#' file with plot data. Default is `FALSE`. See details.
#' @param del_temp `TRUE` (default) to delete the temporary JSON file with plot
#'  data.
#' @param render_plot `TRUE` (default) to render plot using matplotlib.
#' @param ... Additional parameters to modify the plot's format.
#' * `time_label` = text to display in the time axis.
#' * `rec_label` = text to display in the axis counting recurrent events.
#' * `pred_label` = text do display in the risk prediction axis.
#' * `pred_lim` = limits of the risk prediction axis (disables automatic limits).
#' * `pred_ticksize` = size of risk prediction axis ticks.
#' * `lgnd_fontsize` = size of legend font.
#' * `max_lgnd_cols` = columns in legend.
#' * `sc_marker` = marker of recurrent event times.
#' * `text_plot` = TRUE to include an explanatory text with the prediction interval.
#' * `x_major_scale` = major time ticks are multiples of this number.
#' * `x_minor_scale` = minor time ticks are multiples of this number.
#' * `ci_alpha` = transparency of the confidence interval region.
#' * `dpi` = figure dots per inch.
#'
#' @return Silent. Crates a file with the plot in the specified path.
#'
#' @examples
#'
#' @export
predict_plot.SharedModel <- function(obj, filename, t, ws, individuals,
                                     CI_method = 'MC', sig = 0.05, MC_B=100,
                                     numint_nodes = NULL,
                                     check_temp = FALSE, del_temp=TRUE,
                                     render_plot = TRUE, ...){

  # There is nothing to do
  if (del_temp & !render_plot){
    warning('Function was called with no expected output.',
         call. = FALSE)
    return()
  }

  # Check if suggested packages are installed
  check_suggested_packages(c('jsonlite', 'rlist'))

  if (render_plot){

    # Check R interface to python
    check_suggested_packages(c('reticulate'))

    # Check if matplotlib installed
    if (!reticulate::py_module_available('matplotlib')){
      stop('This functionality requires matplotlib to be installed.',
           call. = FALSE)
    }
  }

  # Build JSON file directory from filename
  JSON_filename <- paste(dirname(filename), '/',
                         'temp_',
                         tools::file_path_sans_ext(basename(filename)),
                         '.json',
                         sep = '')

  # Check if file is present
  if (check_temp & file.exists(JSON_filename)){
    JSON_exists <- TRUE
  } else {
    JSON_exists <- FALSE
  }

  # Stop if JSON exits and there is no plot to make
  if (JSON_exists & !render_plot){
    warning('JSON file already exists. Set render_plot=TRUE for plotting.',
         call. = FALSE)
    return()
  }

  # If it is not present, create it
  if (!JSON_exists){
    JSON_created <- create_predict_json(obj, JSON_filename, t, ws, individuals,
                                        CI_method, sig, MC_B, numint_nodes)
  } else {
    JSON_created <- FALSE
  }

  # Success message
  if (JSON_created & (!del_temp)){
    cat(paste('Successfully created', JSON_filename, '\n'))
  }

  # Call the python function with options in ...
  if (render_plot){
    reticulate::source_python(system.file('shared_frailty_plot.py',
                                          package = getPackageName()))

    # Python function call. Pass additional arguments as options
    shared_frailty_plot(JSON_filename, filename,
                        frmt_options=reticulate::dict(...))

    # Success messages
    cat(paste('Successfully created', filename, '\n'))

    if (JSON_exists){
      cat(paste('Information source:', JSON_filename, '\n'))
    }

    # Delete the temporal json
    if (file.exists(JSON_filename) & del_temp & (! JSON_exists) ){
      file.remove(JSON_filename)
    }
  }

  # Return silently
  invisible()
}
