% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shared_frailty_fit.R
\name{shared_frailty_fit}
\alias{shared_frailty_fit}
\title{Fit Shared Frailty Model}
\usage{
shared_frailty_fit(
  data,
  terminal_formula,
  recurrent_formula,
  obsvar,
  ter_hazard,
  rec_hazard,
  rec_timescale,
  frailty,
  rec_piecewise_ts = NULL,
  int_mode = "ISQMC",
  MC_N = 1000,
  GC_nodes = 32,
  is_control = list(dist = "gamma", param = list(1, 1)),
  anal.grad = TRUE,
  BHHH.hessian = FALSE,
  param_scale = "auto",
  positivity_cons = "auto",
  ini_guess = NULL,
  gradtol = 1e-06,
  steptol = 1e-06,
  iterlim = 200,
  print_level = 0
)
}
\arguments{
\item{data}{data.frame with sample, in the following format. A ROW is a time
observations. In COLUMNS one must provide:
\itemize{
\item Time of the observation.
\item Observation unit
\item Indicator of terminal event happening
\item Indicator of recurrent event happening
\item Covariate values
}}

\item{terminal_formula}{Formula for the terminal event.}

\item{recurrent_formula}{Formula for the recurrent event.}

\item{obsvar}{Varible indicating observation units (individuals)}

\item{ter_hazard}{Parametric specification of the baseline hazard for the
terminal event. Supports: \code{"Weibull"}, \code{"loglogistic"}.}

\item{rec_hazard}{Parametric specification of the baseline hazard for the
recurrent event. Supports: \code{"Weibull"}, \code{"loglogistic"}.}

\item{rec_timescale}{Model specification for the hazard of the recurrent event.
Supports: \code{"Poisson"}, \code{"renewal"}, and \code{"piecewise-renewal"}.}

\item{frailty}{Distribution of the frailty variable. Supports: \code{"gamma"}.}

\item{rec_piecewise_ts}{Thresholds for the piecewise-renewal timescale. See details.}

\item{int_mode}{How to compute the numerical integrals:
\itemize{
\item \code{"GQ"} = Gaussian Quadrature.
\item \code{"MC"} = Monte Carlo, with R sampler.
\item \code{"QMC"} = Quasi Monte Carlo, with van der Corput sequence.
\item \code{"ISMC"} = Importance Sampling MC.
\item \code{"ISQMC"} = Importance Sampling QMC (the default).
}}

\item{MC_N}{Number of points for Monte Carlo integration.}

\item{GC_nodes}{Number of points for Gaussian Quadrature integration.}

\item{is_control}{list with Importance Sampling control parameters.
\itemize{
\item \verb{$dist} = distribution to sample from. Any \code{\link[stats:Distributions]{stats::Distributions()}} is valid.
Default is \code{"gamma"} which samples from \code{\link[stats:GammaDist]{stats::dgamma()}}.
\item \verb{$param} = list with parameters to pass to the R sampler. Default is \code{list(1,1)}.
}}

\item{anal.grad}{Whether to use the analytic gradient = \code{TRUE} (default) or \code{FALSE}.}

\item{BHHH.hessian}{Wheter to use the Berndt-Hall-Hall-Haussman algorithm, which
approximates the Hessian of the loglikelihood using scores. It can be \code{TRUE},
use BHHH Hessian in optimization, or \code{FALSE} (default), numerically compute the
Hessian.}

\item{param_scale}{Scale of the parameters. It may speed up convergence.
Values = \code{"auto"} (default), for automatic scalling, \code{"same"}, for equal scalling,
or \verb{numeric(parameter length)}, for customized scalling.}

\item{positivity_cons}{Whether to impose a positivity constraint when maximizing.
Values = \code{"auto"} (default), for automatic selection of the constrained parameters,
\code{"none"}, for optimization without constraints, or \verb{logical(parameter length)},
for customized positivity constraints.}

\item{ini_guess}{\verb{numeric(parameter length)} Initial guess for parameters.
If \code{NULL} (default), the function will use the default initial guess.}

\item{gradtol}{Tolerance for the gradient, see \code{\link[stats:nlm]{stats::nlm()}}.}

\item{steptol}{Tolerance for the steps, see \code{\link[stats:nlm]{stats::nlm()}}.}

\item{iterlim}{Iteration limit, see \code{\link[stats:nlm]{stats::nlm()}}.}

\item{print_level}{Constrols console output. Values = \code{0}, \code{1}, or \code{2};
where \code{2} indicates more verbose. See \code{\link[stats:nlm]{stats::nlm()}}.}
}
\value{
\code{\link[=SharedModel]{SharedModel()}} object with fit results.
}
\description{
\code{shared_frailty_fit()} fits a shared frailty model for terminal and recurrent
events.
}
\details{
Model for the hazard of the terminal event (d) and recurrent event (r)
processes:
\deqn{  \lambda_i^d(t) = u_i^\alpha \cdot
\exp(\beta_d'Z_i) \cdot \lambda_0^d(t) }
\deqn{ \lambda_i^r(t) = u_i \cdot
\exp(\beta_r'Z_i) \cdot \lambda_0^r(t|N_i^r(t)),}
where \eqn{u_i} is the frailty of unit \eqn{i}, \eqn{Z_i} are covariates,
\eqn{h_0^d(t)} is the baseline hazard for the terminal event, and
\eqn{\lambda_0^r(t|N_i^r(t))} is the hazard for the recurrent event given the
history of recurrent events \eqn{N_i(t)}.

If \code{rec_timescale = "Poisson"}, the hazard for recurrent events is
\eqn{\lambda_0^r(t|N_i^r(t))=h_0^r(t)}, where \eqn{h_0^r(t)} is the baseline
hazard for recurrent events.

If \code{rec_timescale = "renewal"}, the hazard for
recurrent events is \eqn{\lambda_0^r(t|N_i^r(t))=h_0^r(t - T^r_{i, N_i(t-)})}.
In the preceeding equation, \eqn{T^r_{i, N_i(t-)}} represents the time of the
last recurrent event before time \eqn{t}, so the renewal time scale fits the
model in gap times.

If \code{rec_timescale = "piecewise-renewal"}, the hazard for recurrent events is
\deqn{\lambda_0^r(t|N_i^r(t))= \sum_{k=1}^K c_k h_0^r(t - T^r_{i, N_i(t-)})
1(\tau_{k-1} \leq t < \tau_k),}
where \eqn{c_k} are constants, \eqn{\tau_k} are thresholds, and \eqn{1(\cdot)}
is the indicator function. The following normalizations are in place: \eqn{c_1=1},
\eqn{\tau_0=0}, and \eqn{\tau_K=\infty}. The remaining \eqn{K - 1} thresholds
must be supplied by the \code{rec_piecewise_ts} argument.

When \code{ter_hazard = "Weibull"} or \code{rec_hazard = "Weibull"}, the corresponding
baseline hazards are
\deqn{h_0(t) = b t^{b-1}/a^b,}
where \eqn{a} is a scale parameter and \eqn{b} is a shape parameter.

When \code{ter_hazard = "loglogistic"} or \code{rec_hazard = "loglogistic"}, the
corresponding baseline hazards are
\deqn{h_0(t) = \frac{b}{a}\frac{(t/a)^{b-1}}{1 + (t/a)^b},}
where \eqn{a} is a scale parameter and \eqn{b} is a shape parameter.

For \code{frailty = "gamma"} the distribution of \eqn{u_i} is
\deqn{\frac{u^{1/\sigma-1}\exp(-u/\sigma)}{\sigma^{1/\sigma}\Gamma(1/\sigma)},}
where \eqn{\sigma = Var(u_i)}. Also, \eqn{E[u_i]=1}.

Maximum likelihood estimation is performed using \code{\link[stats:nlm]{stats::nlm()}}.
}
